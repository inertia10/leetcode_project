### 解题思路
#### 思路

首先把题目抽丝剥茧，题目套了个剪绳子的壳子。其实就是数字n，如何分解保证乘积最大。不妨举几个例子：

第一步：定义dp[n]的值的含义为：数字n的乘积最大值

```java
n=2:  1+1  -->1*1=1;   				dp[2]=1;
n=3:  2+1  -->2*1=2;   				dp[3]=2;
n=4:  2+2  -->2*2=4;   				dp[4]=4;
n=5:  3+2  -->3*2=6;   				dp[5]=6;
貌似看不出规律，别急再多写几个
n=6:  3+3  -->3*3=4;                 dp[6]=9;
n=7:  4+3  -->4*3=12;-->dp[4]*3=12   dp[7]=12;
n=8:  5+3  -->6*3=12;-->dp[5]*3=18   dp[8]=18;
n=9:  6+3  -->9*3=12;-->dp[6]*3=27   dp[9]=27;
n=10: 7+3  -->12*3=36;-->dp[7]*3=12   dp[10]=36;
```

第二步：找到递推的规律：

通过上述分析，规律明显在n=7以后为

```java
if(n>=7)
	dp[n] = dp[n-3]*3;
```

第三步：找初始值：

初始值在第二步找规律已经找到了

```java
n=2:  1+1  -->1*1=1;   				dp[2]=1;
n=3:  2+1  -->2*1=2;   				dp[3]=2;
n=4:  2+2  -->2*2=4;   				dp[4]=4;
n=5:  3+2  -->3*2=6;   				dp[5]=6;
n=6:  3+3  -->3*3=4;                dp[6]=9;
```

通过以上分析，就直接可以写代码了：

### 代码

*执行耗时:0 ms,击败了100.00% 的Java用户*
*内存消耗:36.1 MB,击败了100.00% 的Java用户*

```java
//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int cuttingRope(int n) {
        //1.创建数组-设置对应的含义,dp[n]为长度为 n 时候，最大的乘积 我们只需求出dp[n]
        int[] dp = new int[n+7];
        //3.确定初始值
        dp[0]=0;
        dp[1]=0;
        dp[2]=1;
        dp[3]=2;
        dp[4]=4;
        dp[5]=6;
        dp[6]=9;
        if(n<=6){return dp[n];}
        //2.找到递推关系
        for (int i = 7; i <= n; i++) {
            dp[i] = dp[i-3]*3;
        }
        return dp[n];
    }
}
//leetcode submit region end(Prohibit modification and deletion)

```

其实还可以优化上述代码，因为只用要一个变量dp[i-3],不断的更新dp[i-3]即可。